[{"authors":["admin"],"categories":null,"content":"I\u0026rsquo;ve been applying computational science to various problems for 20 years. First as a research scientist studying flood risk management and geoengineering assessment and more recently in the private sector on environmental, insurance, and site planning projects. I\u0026rsquo;m hugely appreciative of the Open Source community - I\u0026rsquo;ve learnt so much from the posts and tutorials generously supplied by others. I mostly work with R. This is my contribution, it\u0026rsquo;s partly a place for me to make a record of methods I\u0026rsquo;ve used that have worked so that I can find them again, and partly a means to share those methods in the hope they might help someone else. Keep the community vibrant. UseR.\n","date":1554595200,"expirydate":-62135596800,"kind":"taxonomy","lang":"en","lastmod":1554595200,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"/author/david-leedal/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/author/david-leedal/","section":"authors","summary":"I\u0026rsquo;ve been applying computational science to various problems for 20 years. First as a research scientist studying flood risk management and geoengineering assessment and more recently in the private sector on environmental, insurance, and site planning projects.","tags":null,"title":"David Leedal","type":"authors"},{"authors":[],"categories":null,"content":" Click on the Slides button above to view the built-in slides feature.   Slides can be added in a few ways:\n Create slides using Academic\u0026rsquo;s Slides feature and link using slides parameter in the front matter of the talk file Upload an existing slide deck to static/ and link using url_slides parameter in the front matter of the talk file Embed your slides (e.g. Google Slides) or presentation video on this page using shortcodes.  Further talk details can easily be added to this page using Markdown and $\\rm \\LaTeX$ math code.\n","date":1906549200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1906549200,"objectID":"96344c08df50a1b693cc40432115cbe3","permalink":"/talk/example/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/talk/example/","section":"talk","summary":"An example talk using Academic's Markdown slides feature.","tags":[],"title":"Example Talk","type":"talk"},{"authors":[],"categories":["r"],"content":"       Given a point, what highway is it on and what direction does that highway go? I’m kicking off this blog with a geospatial example. I did some work recently where I needed to know:\n the nearest section of highway to a given point; and, the highways’s approximate bearing.  I got this working pretty well and am repeating the crux of the solution here. As an aside, while I was doing this work I came across Geoff Boeing’s beautiful post visualising similar aggregate directional information for 25 cities - definitely worth a look.\nThe best approach I could think of was to use OpenStreetMap data. Firstly associate a point with it’s nearest highway ‘way’ feature. Then get the coordinates of the beginning and end of the feature and use the pair of points to define a bearing. Makes sense? OK, here we go:\n Get the packages library(geosphere) library(sf) library(leaflet) library(osmdata) library(data.table) library(ggmap)  Organise the data To keep things manageable I’m going to use 4 points dotted around the Northern Quarter in Manchester (UK). I’ll put them in a data.frame:\ndf \u0026lt;- data.frame(ID = 1:4, Longitude = c(-2.232086, -2.235675, -2.233628, -2.232453), Latitude = c(53.484510, 53.484318, 53.484103, 53.481176), stringsAsFactors = FALSE) Then I’ll convert to an sf (spatial features) multi point object. I use this command over and over.\ndf.sf \u0026lt;- st_as_sf(df, coords = c(\u0026quot;Longitude\u0026quot;, \u0026quot;Latitude\u0026quot;), crs=4326) The crs argument is telling st_as_sf that these coordinates are WGS84 by referencing the appropriate EPSG code 4326 (it’s a good idea to memorise that number!). This is needed later when I project the points out of latitude/longitude format and into distance-from-bottom-left format. If you’re not familiar with this concept here’s a good pdf tutorial.\n Visualise At this point I’ll take a look at the 4 points. I’m using leaflet which works well with Blogdown.\nm \u0026lt;- leaflet(df) %\u0026gt;% addTiles() %\u0026gt;% addCircleMarkers( lng = ~Longitude, lat = ~Latitude, radius = 8, color = \u0026quot;green\u0026quot;, stroke = FALSE, fillOpacity = 0.9 ) m  {\"x\":{\"options\":{\"crs\":{\"crsClass\":\"L.CRS.EPSG3857\",\"code\":null,\"proj4def\":null,\"projectedBounds\":null,\"options\":{}}},\"calls\":[{\"method\":\"addTiles\",\"args\":[\"//{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\",null,null,{\"minZoom\":0,\"maxZoom\":18,\"tileSize\":256,\"subdomains\":\"abc\",\"errorTileUrl\":\"\",\"tms\":false,\"noWrap\":false,\"zoomOffset\":0,\"zoomReverse\":false,\"opacity\":1,\"zIndex\":1,\"detectRetina\":false,\"attribution\":\"\u0026copy; OpenStreetMap contributors, CC-BY-SA\"}]},{\"method\":\"addCircleMarkers\",\"args\":[[53.48451,53.484318,53.484103,53.481176],[-2.232086,-2.235675,-2.233628,-2.232453],8,null,null,{\"interactive\":true,\"className\":\"\",\"stroke\":false,\"color\":\"green\",\"weight\":5,\"opacity\":0.5,\"fill\":true,\"fillColor\":\"green\",\"fillOpacity\":0.9},null,null,null,null,null,{\"interactive\":false,\"permanent\":false,\"direction\":\"auto\",\"opacity\":1,\"offset\":[0,0],\"textsize\":\"10px\",\"textOnly\":false,\"className\":\"\",\"sticky\":true},null]}],\"limits\":{\"lat\":[53.481176,53.48451],\"lng\":[-2.235675,-2.232086]}},\"evals\":[],\"jsHooks\":[]}  Get information from OpenStreetMap The opq query from the osmdata package forms an OSM overpass filter and sends it to OSM’s servers. The result is an osmdata object containing various items. The item I’m interested in is the osm_lines which is a set of sf linestrings. These are the way objects representing highway segments. The query has returned 44 highway segments that intersected the bounded box of our 4 points (at the time of posting).\nthis.bbox \u0026lt;- st_bbox(df.sf) osm.road.types = c(\u0026quot;motorway\u0026quot;, \u0026quot;motorway_link\u0026quot;, \u0026quot;trunk\u0026quot;, \u0026quot;trunk_link\u0026quot;, \u0026quot;primary\u0026quot;, \u0026quot;primary_link\u0026quot;, \u0026quot;secondary\u0026quot;, \u0026quot;secondary_link\u0026quot;, \u0026quot;tertiary\u0026quot;, \u0026quot;unclassified\u0026quot;, \u0026quot;residential\u0026quot;) out \u0026lt;- opq (this.bbox) %\u0026gt;% add_osm_feature (key = \u0026quot;highway\u0026quot;, value = osm.road.types) %\u0026gt;% osmdata_sf(quiet = F) ## Issuing query to Overpass API ... ## Rate limit: 2 ## Query complete! ## converting OSM data to sf format out ## Object of class \u0026#39;osmdata\u0026#39; with: ## $bbox : 53.481176,-2.235675,53.48451,-2.232086 ## $overpass_call : The call submitted to the overpass API ## $meta : metadata including timestamp and version numbers ## $osm_points : \u0026#39;sf\u0026#39; Simple Features Collection with 199 points ## $osm_lines : \u0026#39;sf\u0026#39; Simple Features Collection with 44 linestrings ## $osm_polygons : \u0026#39;sf\u0026#39; Simple Features Collection with 0 polygons ## $osm_multilines : NULL ## $osm_multipolygons : NULL road.lines \u0026lt;- out$osm_lines nrow(road.lines) ## [1] 44  Get candidate closest roads to points Soon I’ll find the closest highway segment to each point, but if I had thousands of points and highways it would be wise to only check a subset of highways by associating nearby highways to each point. I’ll do that next. First I’ll project the points and the road segments to a suitable coordinate reference system (for Manchester, the UK Ordnance Survay EPSG: 27700 is a good choice), apply a 50m buffer to the points, then identify which road segments intersect with this buffer.\ndf.sf.tf \u0026lt;- st_transform(df.sf, 27700) # US National Atlas Equal Area projection road.lines.tf \u0026lt;- st_transform(road.lines, 27700) buffer.size \u0026lt;- 50 df.sf.tf.bf \u0026lt;- st_buffer(df.sf.tf, buffer.size) intersected.items \u0026lt;- st_intersects(df.sf.tf.bf, road.lines.tf, sparse = F) dim(intersected.items) ## [1] 4 44 The dimensions show I have 4 rows, one for each of the 4 points, and 44 columns, one for each OSM road segment within the bounding box. The matrix contains TRUE/FALSE values where TRUE indicates a point of intersection.\n Get the closest road segment So now, using the location of TRUE values in each row or the intersected.items matrix, I can subset the road.lines so that the nearest highway search is constrained to a much smaller number of highway segments (ones within 50m). The st_coordinates function is useful to return just the coordinate information from an sf object, and the dist2Line function from the geosphere package calculates the shortest distance between a point and a polyline (There are some good details about doing this type of calculation at the Movable Type website.\nnumber.of.point \u0026lt;- nrow(intersected.items) distances.vect \u0026lt;- matrix(NA_real_, nrow = nrow(df.sf.tf), ncol = 4) colnames(distances.vect) \u0026lt;- c(\u0026quot;distance\u0026quot;, \u0026quot;lon\u0026quot;, \u0026quot;lat\u0026quot;, \u0026quot;ID\u0026quot;) for (i in seq_len(number.of.point)) { # Out of all 44 road segments, get the index of the ones that are within 50m of point i. original.road.idx \u0026lt;- which(intersected.items[i, ] == TRUE) distances.vect.temp \u0026lt;- dist2Line(p = st_coordinates(df.sf[i, ]), line = as_Spatial(road.lines[original.road.idx, ])) distances.vect.temp[1, \u0026quot;ID\u0026quot;] \u0026lt;- original.road.idx[distances.vect.temp[1, \u0026quot;ID\u0026quot;]] distances.vect[i, ] \u0026lt;- distances.vect.temp } distances.vect ## distance lon lat ID ## [1,] 5.061288 -2.232137 53.48448 43 ## [2,] 3.500525 -2.235712 53.48430 10 ## [3,] 6.111912 -2.233558 53.48407 5 ## [4,] 5.541079 -2.232491 53.48122 19 So now I’ve got the nearest road segments and the coordinates of the nearest point on the road segments to the original points. These are stored in the lon/lat columns of distances.vec. So the original vague points are now snapped to actual highway locations which is a bonus.\n Get the road section bearings Next I’ll extract the chosen 4 road segments from the full set of 44 and add the useful features I’ve just created so far. Getting the coordinates of the first and last points is a bit fiddly. I’m using data.table for this. When retrieving the coordinates via st_coordinates a third column labelled L1 is created with a group ID of each polyline object. This can be used as a grouping variable in data.table. The .SD[...] syntax holds the sub-data.table once the full data.table has been split by the grouping variable, finally 1 and .N are the first row and last row of each sub-data.table. There’s other ways to do this but the speed of data.table would pay off if I had thousands of points. Once we have the beginning and end coordinate pairs it’s straightforward to call the bearing function from the geosphere package.\nout \u0026lt;- road.lines[as.integer(distances.vect[, \u0026quot;ID\u0026quot;]), ] out$dist.to.nearest \u0026lt;- distances.vect[, \u0026quot;distance\u0026quot;] out$snap.lat \u0026lt;- distances.vect[, \u0026quot;lat\u0026quot;] out$snap.lon \u0026lt;- distances.vect[, \u0026quot;lon\u0026quot;] matching.road.lines.coords \u0026lt;- data.table::as.data.table(st_coordinates(out)) matching.road.lines.coords.begin \u0026lt;- as.matrix(matching.road.lines.coords[, .SD[1, .(X, Y)], by = \u0026quot;L1\u0026quot;][, L1 := NULL]) matching.road.lines.coords.end \u0026lt;- as.matrix(matching.road.lines.coords[, .SD[.N, .(X, Y)], by = \u0026quot;L1\u0026quot;][, L1 := NULL]) matching.road.lines.bearing \u0026lt;- bearing(matching.road.lines.coords.begin, matching.road.lines.coords.end) out$bearing \u0026lt;- (matching.road.lines.bearing + 360) %% 360 out$bearing ## [1] 133.2409 316.6075 217.5574 258.1974  Plot with estimated bearing In order to visualise the estimated road bearing for my 4 points I need to add arrow endpoints information. Some trigonometry wil accomplish this (the 0.00025 value is determines the length of the direction arrow):\nout$delta.x \u0026lt;- sin((pi*out$bearing) / 180) * 0.00025 out$delta.y \u0026lt;- cos((pi*out$bearing) / 180) * 0.00025 Now I can plot the snapped locations and show an arrow indicating the highway bearing over a basemap which is not only pretty but allows for a quick visual validation.\n# A handcoded bounding box for tile retrieval. A function to make this would be a nice addition. n.quarter.bb \u0026lt;- c(left = -2.236, bottom = 53.48, right = -2.23, top = 53.485) n.quarter \u0026lt;- get_stamenmap(bbox = n.quarter.bb, zoom = 18, messaging = FALSE) ggmap(n.quarter) + geom_point(data = out, aes(x=snap.lon, y=snap.lat), colour = \u0026quot;darkgreen\u0026quot;, size = 4) + geom_segment(data = out, aes(x=snap.lon, y=snap.lat, xend = snap.lon + delta.x, yend = snap.lat + delta.y), colour = \u0026quot;darkgreen\u0026quot;, arrow = arrow(length = unit(0.2,\u0026quot;cm\u0026quot;)))  Summary The results are pretty good, definitely good enough to classify a point into one of the 8 compass bearing directions: N, NE, E… etc. In this post I’ve explored working with sf spatial points, generated and run an OSM overpass filter, and done some useful visualisation with Leaflet and ggmap. I’m sure there are things I could tidy and optimise here but I hope you found this a little useful.\n ","date":1593993600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1594031731,"objectID":"c831559fd6c150f6b7eaf95f37d67943","permalink":"/post/collecting-highway-bearings/","publishdate":"2020-07-06T00:00:00Z","relpermalink":"/post/collecting-highway-bearings/","section":"post","summary":"Given a point, what highway is it on and what direction does that highway go? I’m kicking off this blog with a geospatial example.","tags":["r","geospatial","sf","osm"],"title":"Collecting Highway Bearings","type":"post"},{"authors":["David Leedal"],"categories":null,"content":" Click the Slides button above to demo Academic\u0026rsquo;s Markdown slides feature.   Supplementary notes can be added here, including code and math.\n","date":1554595200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1554595200,"objectID":"557dc08fd4b672a0c08e0a8cf0c9ff7d","permalink":"/publication/preprint/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/preprint/","section":"publication","summary":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum.","tags":["source themes"],"title":"An example preprint / working paper","type":"publication"},{"authors":[],"categories":[],"content":"Create slides in Markdown with Academic  Academic | Documentation\n Features  Efficiently write slides in Markdown 3-in-1: Create, Present, and Publish your slides Supports speaker notes Mobile friendly slides   Controls  Next: Right Arrow or Space Previous: Left Arrow Start: Home Finish: End Overview: Esc Speaker notes: S Fullscreen: F Zoom: Alt + Click  PDF Export: E   Code Highlighting Inline code: variable\nCode block:\nporridge = \u0026quot;blueberry\u0026quot; if porridge == \u0026quot;blueberry\u0026quot;: print(\u0026quot;Eating...\u0026quot;)   Math In-line math: $x + y = z$\nBlock math:\n$$ f\\left( x \\right) = ;\\frac{{2\\left( {x + 4} \\right)\\left( {x - 4} \\right)}}{{\\left( {x + 4} \\right)\\left( {x + 1} \\right)}} $$\n Fragments Make content appear incrementally\n{{% fragment %}} One {{% /fragment %}} {{% fragment %}} **Two** {{% /fragment %}} {{% fragment %}} Three {{% /fragment %}}  Press Space to play!\nOne  Two  Three \n A fragment can accept two optional parameters:\n class: use a custom style (requires definition in custom CSS) weight: sets the order in which a fragment appears   Speaker Notes Add speaker notes to your presentation\n{{% speaker_note %}} - Only the speaker can read these notes - Press `S` key to view {{% /speaker_note %}}  Press the S key to view the speaker notes!\n Only the speaker can read these notes Press S key to view    Themes  black: Black background, white text, blue links (default) white: White background, black text, blue links league: Gray background, white text, blue links beige: Beige background, dark text, brown links sky: Blue background, thin dark text, blue links    night: Black background, thick white text, orange links serif: Cappuccino background, gray text, brown links simple: White background, black text, blue links solarized: Cream-colored background, dark green text, blue links   Custom Slide Customize the slide style and background\n{{\u0026lt; slide background-image=\u0026quot;/img/boards.jpg\u0026quot; \u0026gt;}} {{\u0026lt; slide background-color=\u0026quot;#0000FF\u0026quot; \u0026gt;}} {{\u0026lt; slide class=\u0026quot;my-style\u0026quot; \u0026gt;}}   Custom CSS Example Let\u0026rsquo;s make headers navy colored.\nCreate assets/css/reveal_custom.css with:\n.reveal section h1, .reveal section h2, .reveal section h3 { color: navy; }   Questions?  Ask\n Documentation\n","date":1549324800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1549324800,"objectID":"0e6de1a61aa83269ff13324f3167c1a9","permalink":"/slides/example/","publishdate":"2019-02-05T00:00:00Z","relpermalink":"/slides/example/","section":"slides","summary":"An introduction to using Academic's Slides feature.","tags":[],"title":"Slides","type":"slides"},{"authors":["David Leedal","robert ford"],"categories":null,"content":" Click the Cite button above to demo the feature to enable visitors to import publication metadata into their reference management software.    Click the Slides button above to demo Academic\u0026rsquo;s Markdown slides feature.   Supplementary notes can be added here, including code and math.\n","date":1441065600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1441065600,"objectID":"966884cc0d8ac9e31fab966c4534e973","permalink":"/publication/journal-article/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/journal-article/","section":"publication","summary":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum.","tags":["source themes"],"title":"An example journal article","type":"publication"},{"authors":["David Leedal","robert ford"],"categories":null,"content":" Click the Cite button above to demo the feature to enable visitors to import publication metadata into their reference management software.    Click the Slides button above to demo Academic\u0026rsquo;s Markdown slides feature.   Supplementary notes can be added here, including code and math.\n","date":1372636800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1372636800,"objectID":"69425fb10d4db090cfbd46854715582c","permalink":"/publication/conference-paper/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/conference-paper/","section":"publication","summary":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum.","tags":["source themes"],"title":"An example conference paper","type":"publication"}]